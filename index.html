<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Sandbox</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #282c34;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 0;
            box-sizing: border-box;
        }

        canvas {
            display: block;
            background-color: #1a1e24;
            width: 100vw;
            height: 100vh;
        }

        #controlsContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .control-button {
            background-color: #4a4f58;
            border: none;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s ease, transform 0.2s ease;
            color: #e0e0e0;
        }

        .control-button:hover {
            background-color: #5a5f68;
            transform: translateY(-2px);
        }

        #removeItemsButton.active {
            background-color: #dc3545;
            box-shadow: 0 0 15px rgba(220, 53, 69, 0.7);
        }

        #infoButton.active {
            background-color: #61dafb;
            box-shadow: 0 0 15px rgba(97, 218, 251, 0.7);
        }

        .control-button svg {
            width: 24px;
            height: 24px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #3a3f47;
            margin: auto;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.5);
            max-width: 500px;
            width: 90%;
            position: relative;
            color: #e0e0e0;
            text-align: center;
        }

        .modal-content h2 {
            color: #61dafb;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .modal-content p {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: #e0e0e0;
            text-decoration: none;
            cursor: pointer;
        }

        #sideMenu {
            height: 100%;
            width: 0;
            position: fixed;
            z-index: 1500;
            top: 0;
            right: 0;
            background-color: #3a3f47;
            overflow-x: hidden;
            transition: 0.5s;
            padding-top: 60px;
            box-shadow: -4px 0 8px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #sideMenu.open {
            width: 250px;
        }

        #sideMenu .close-button {
            position: absolute;
            top: 10px;
            left: 20px;
        }

        #sideMenu h2 {
            color: #61dafb;
            margin-bottom: 30px;
            text-align: center;
        }

        #sideMenu button {
            background-color: #4a4f58;
            color: #e0e0e0;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            margin-bottom: 15px;
            cursor: pointer;
            width: 80%;
            font-size: 1.1em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease, transform 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        #sideMenu button:hover {
            background-color: #5a5f68;
            transform: translateY(-1px);
        }

        #sideMenuOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
            z-index: 1400;
        }

        #contextMenu {
            display: none;
            position: absolute;
            background-color: #3a3f47;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            z-index: 2100;
            padding: 5px 0;
            min-width: 150px;
        }

        #contextMenu button {
            background: none;
            border: none;
            color: #e0e0e0;
            padding: 10px 15px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
            border-radius: 0;
            box-shadow: none;
            margin-bottom: 0;
        }

        #contextMenu button:hover {
            background-color: #5a5f68;
            transform: none;
        }

        #uploadChoiceModal .modal-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 25px;
        }

        #uploadChoiceModal button {
            background-color: #61dafb;
            color: #282c34;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        #uploadChoiceModal button:hover {
            background-color: #4dc1e8;
            transform: translateY(-2px);
        }

        #quantityModal .modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #quantityModal input[type="number"] {
            width: 80%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #5a5f68;
            background-color: #282c34;
            color: #e0e0e0;
            font-size: 1em;
            text-align: center;
        }

        #quantityModal button {
            background-color: #61dafb;
            color: #282c34;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            width: 80%;
        }

        #quantityModal button:hover {
            background-color: #4dc1e8;
            transform: translateY(-2px);
        }

        /* Custom Tooltip Styles */
        #customTooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            pointer-events: none; /* Allow clicks to pass through */
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 2500; /* Above all other UI elements */
            white-space: nowrap;
        }

        #customTooltip.show {
            opacity: 1;
        }

        /* Custom Message Box Styles */
        #messageBox {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #61dafb;
            color: #282c34;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            font-size: 1.1em;
            font-weight: bold;
            text-align: center;
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        #messageBox.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="controlsContainer">
        <button id="addItemsButton" class="control-button" aria-label="Add Items" data-tooltip="Open Add Objects Menu">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 5V19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M5 12H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
        <button id="removeItemsButton" class="control-button" aria-label="Remove Items" data-tooltip="Toggle Object Removal Mode">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 6H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M10 11V17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M14 11V17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
        <button id="infoButton" class="control-button" aria-label="Simulator Information" data-tooltip="View Simulator Information">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 16V12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 8H12.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
        <button id="menuButton" class="control-button" aria-label="Controls Menu" data-tooltip="View Simulator Controls">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="5" r="2" fill="currentColor"/>
                <circle cx="12" cy="12" r="2" fill="currentColor"/>
                <circle cx="12" cy="19" r="2" fill="currentColor"/>
            </svg>
        </button>
    </div>

    <canvas id="physicsCanvas"></canvas>

    <div id="controlsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeModalBtn">&times;</span>
            <h2>Simulator Controls</h2>
            <div id="desktopControls">
                <p><strong>Mouse Drag:</strong> Rotate the camera around the simulation.</p>
                <p><strong>Mouse Wheel:</strong> Zoom in and out.</p>
                <p><strong>Right-Click Canvas:</strong> Open a context menu to clear all objects or save the scene state.</p>
            </div>
            <div id="mobileControls" style="display: none;">
                <p><strong>One-Finger Drag:</strong> Rotate the camera around the simulation.</p>
                <p><strong>Two-Finger Pinch:</strong> Zoom in and out.</p>
                <p><strong>Long Press Canvas:</strong> Open a context menu to clear all objects or save the scene state.</p>
            </div>
            <p><strong>Add Items Button:</strong> Click the '+' icon to open the Add Objects menu.</p>
            <p><strong>Right-Click (Desktop) / Long Press (Mobile) on Add Item:</strong> Specify how many to add.</p>
            <p><strong>Remove Items Button:</strong> Click the trash can icon to enter removal mode. Hover/Tap over objects to see a red outline, then click/tap to remove them.</p>
            <p><strong>Add Human Button:</strong> Click the 'Add Human' button in the Add Objects menu to spawn a non-controllable humanoid.</p>
        </div>
    </div>

    <div id="geminiModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeGeminiModalBtn">&times;</span>
            <h2>Made by Gemini</h2>
            <p>This 3D Physics Simulator was created by Gemini.</p>
            <p>It utilizes Three.js for rendering and Cannon.js for physics simulation.</p>
            <p>Enjoy experimenting with physics!</p>
        </div>
    </div>

    <div id="uploadChoiceModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeUploadChoiceModalBtn">&times;</span>
            <h2>Choose Upload Type</h2>
            <button id="uploadSaveFileBtn" data-tooltip="Load a previously saved scene">Upload Save File (.json)</button>
            <button id="import3DModelBtn" data-tooltip="Import a custom 3D model">Import 3D Model (.gltf, .glb)</button>
        </div>
    </div>

    <div id="quantityModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeQuantityModalBtn">&times;</span>
            <h2>How many do you want to add?</h2>
            <input type="number" id="quantityInput" value="1" min="1" max="50">
            <button id="addQuantityBtn">Add to Scene</button>
        </div>
    </div>

    <div id="sideMenuOverlay"></div>
    <div id="sideMenu">
        <span class="close-button" id="closeSideMenuBtn">&times;</span>
        <h2>Add Objects</h2>
        <button id="addSphereBtn" data-object-type="sphere" data-tooltip="Add a single sphere (Left-Click) or multiple (Right-Click)">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
            </svg>
            Add Sphere
        </button>
        <button id="addBoxBtn" data-object-type="box" data-tooltip="Add a single box (Left-Click) or multiple (Right-Click)">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke="currentColor" stroke-width="2"/>
            </svg>
            Add Box
        </button>
        <button id="addCylinderBtn" data-object-type="cylinder" data-tooltip="Add a single cylinder (Left-Click) or multiple (Right-Click)">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <ellipse cx="12" cy="5" rx="8" ry="3" stroke="currentColor" stroke-width="2"/>
                <ellipse cx="12" cy="19" rx="8" ry="3" stroke="currentColor" stroke-width="2"/>
                <line x1="4" y1="5" x2="4" y2="19" stroke="currentColor" stroke-width="2"/>
                <line x1="20" y1="5" x2="20" y2="19" stroke="currentColor" stroke-width="2"/>
            </svg>
            Add Cylinder
        </button>
        <button id="addHumanBtn" data-object-type="human" data-tooltip="Add a single human (Left-Click) or multiple (Right-Click)">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2C10.8954 2 10 2.89543 10 4C10 5.10457 10.8954 6 12 6C13.1046 6 14 5.10457 14 4C14 2.89543 13.1046 2 12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 7V14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M9 10L12 7L15 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M9 14L12 22M15 14L12 22" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            Add Human
        </button>
        <button id="upload3dBtn" data-tooltip="Upload a 3D model or scene file">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 16V8M9 13L12 16L15 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M19 17V17C19 18.6569 17.6569 20 16 20H8C6.34315 20 5 18.6569 5 17V17C5 15.3431 6.34315 14 8 14H16C17.6569 14 19 15.3431 19 17Z" stroke="currentColor" stroke-width="2"/>
            </svg>
            Upload 3D
        </button>
    </div>

    <div id="contextMenu">
        <button id="clearAllObjectsBtn" data-tooltip="Remove all objects from the scene">Clear All Objects</button>
        <button id="saveAs3DModelBtn" data-tooltip="Save the current scene as a JSON file">Save Scene State (.json)</button>
    </div>

    <input type="file" id="fileInput" style="display: none;">

    <div id="customTooltip" class="tooltip"></div>
    <div id="messageBox"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer;
        let world;
        let meshes = [];
        let bodies = [];

        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let cameraTarget = new THREE.Vector3(0, 2, 0);
        let cameraDistance = 15;
        let phi = Math.PI * 0.4;
        let theta = Math.PI * 0.2;

        // Touch control variables
        let isMobile = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoveX = 0;
        let touchMoveY = 0;
        let initialPinchDistance = 0;
        let touchCount = 0;
        let longPressTimer = null;
        const LONG_PRESS_THRESHOLD = 500; // milliseconds

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let highlightedObject = null;
        const originalMaterials = new Map();
        const highlightMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000, emissive: 0x330000 });

        let controlsModal;
        let closeModalBtn;
        let geminiModal;
        let closeGeminiModalBtn;
        let uploadChoiceModal;
        let closeUploadChoiceModalBtn;
        let uploadSaveFileBtn;
        let import3DModelBtn;
        let menuButton;
        let addItemsButton;
        let removeItemsButton;
        let infoButton;
        let sideMenu;
        let closeSideMenuBtn;
        let sideMenuOverlay;
        let addSphereBtn;
        let addBoxBtn;
        let addCylinderBtn;
        let addHumanBtn;
        let upload3dBtn;
        let contextMenu;
        let clearAllObjectsBtn;
        let saveAs3DModelBtn;
        let fileInput;

        let quantityModal;
        let closeQuantityModalBtn;
        let quantityInput;
        let addQuantityBtn;
        let currentObjectTypeToAdd = '';

        let removeModeActive = false;

        const MAX_OBJECTS = 50;

        let customTooltip;
        let tooltipTimeout;
        let currentHoveredMesh = null;
        let meshHoverTimer = null;

        let messageBox;
        let messageBoxTimeout;

        function init() {
            try {
                // Detect mobile device
                isMobile = /Mobi|Android/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

                controlsModal = document.getElementById('controlsModal');
                closeModalBtn = document.getElementById('closeModalBtn');
                geminiModal = document.getElementById('geminiModal');
                closeGeminiModalBtn = document.getElementById('closeGeminiModalBtn');
                uploadChoiceModal = document.getElementById('uploadChoiceModal');
                closeUploadChoiceModalBtn = document.getElementById('closeUploadChoiceModalBtn');
                uploadSaveFileBtn = document.getElementById('uploadSaveFileBtn');
                import3DModelBtn = document.getElementById('import3DModelBtn');
                menuButton = document.getElementById('menuButton');
                addItemsButton = document.getElementById('addItemsButton');
                removeItemsButton = document.getElementById('removeItemsButton');
                infoButton = document.getElementById('infoButton');
                sideMenu = document.getElementById('sideMenu');
                closeSideMenuBtn = document.getElementById('closeSideMenuBtn');
                sideMenuOverlay = document.getElementById('sideMenuOverlay');
                addSphereBtn = document.getElementById('addSphereBtn');
                addBoxBtn = document.getElementById('addBoxBtn');
                addCylinderBtn = document.getElementById('addCylinderBtn');
                addHumanBtn = document.getElementById('addHumanBtn');
                upload3dBtn = document.getElementById('upload3dBtn');
                contextMenu = document.getElementById('contextMenu');
                clearAllObjectsBtn = document.getElementById('clearAllObjectsBtn');
                saveAs3DModelBtn = document.getElementById('saveAs3DModelBtn');
                fileInput = document.getElementById('fileInput');

                quantityModal = document.getElementById('quantityModal');
                closeQuantityModalBtn = document.getElementById('closeQuantityModalBtn');
                quantityInput = document.getElementById('quantityInput');
                addQuantityBtn = document.getElementById('addQuantityBtn');

                customTooltip = document.getElementById('customTooltip');
                messageBox = document.getElementById('messageBox');

                quantityInput.setAttribute('max', MAX_OBJECTS);

                hideAllMenus();

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x282c34);

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                updateCameraPosition();

                const canvas = document.getElementById('physicsCanvas');
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);

                world = new CANNON.World();
                world.gravity.set(0, -9.82, 0);
                world.broadphase = new CANNON.NaiveBroadphase();
                world.solver.iterations = 10;

                const groundGeometry = new THREE.PlaneGeometry(50, 50);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x666666, side: THREE.DoubleSide });
                const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                groundMesh.rotation.x = -Math.PI / 2;
                groundMesh.receiveShadow = true;
                scene.add(groundMesh);

                const groundBoxHalfExtentsPhysics = new CANNON.Vec3(25, 0.1, 25);
                const groundPhysicsShape = new CANNON.Box(groundBoxHalfExtentsPhysics);
                const groundPhysicsBody = new CANNON.Body({ mass: 0, shape: groundPhysicsShape });
                groundPhysicsBody.position.set(0, -groundBoxHalfExtentsPhysics.y, 0);
                world.addBody(groundPhysicsBody);

                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;

                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                createObject('sphere', 5);
                createObject('box', 3);
                createObject('cylinder', 2);
                createObject('human', 1);

                // Conditional event listeners based on device type
                if (isMobile) {
                    canvas.addEventListener('touchstart', onTouchStart, false);
                    canvas.addEventListener('touchmove', onTouchMove, false);
                    canvas.addEventListener('touchend', onTouchEnd, false);
                    canvas.addEventListener('contextmenu', (e) => e.preventDefault(), false); // Prevent default long-press context menu
                    document.getElementById('desktopControls').style.display = 'none';
                    document.getElementById('mobileControls').style.display = 'block';
                } else {
                    canvas.addEventListener('mousedown', onMouseDown, false);
                    canvas.addEventListener('mouseup', onMouseUp, false);
                    canvas.addEventListener('mousemove', onMouseMove, false);
                    canvas.addEventListener('wheel', onMouseWheel, false);
                    canvas.addEventListener('contextmenu', onContextMenu, false);
                    document.getElementById('desktopControls').style.display = 'block';
                    document.getElementById('mobileControls').style.display = 'none';
                }
                canvas.addEventListener('click', onClickCanvas, false); // Click/tap for removal mode

                window.addEventListener('resize', onWindowResize, false);

                infoButton.addEventListener('click', () => {
                    hideAllMenus();
                    geminiModal.style.display = 'flex';
                });
                menuButton.addEventListener('click', () => {
                    hideAllMenus();
                    controlsModal.style.display = 'flex';
                });

                closeModalBtn.addEventListener('click', () => { controlsModal.style.display = 'none'; });
                closeGeminiModalBtn.addEventListener('click', () => { geminiModal.style.display = 'none'; });
                closeUploadChoiceModalBtn.addEventListener('click', () => { uploadChoiceModal.style.display = 'none'; });
                closeQuantityModalBtn.addEventListener('click', () => { quantityModal.style.display = 'none'; });

                window.addEventListener('click', (event) => {
                    if (event.target == controlsModal) {
                        controlsModal.style.display = 'none';
                    }
                    if (event.target == geminiModal) {
                        geminiModal.style.display = 'none';
                    }
                    if (event.target == uploadChoiceModal) {
                        uploadChoiceModal.style.display = 'none';
                    }
                    if (event.target == quantityModal) {
                        quantityModal.style.display = 'none';
                    }
                });

                addItemsButton.addEventListener('click', () => {
                    hideAllMenus();
                    sideMenu.classList.add('open');
                    sideMenuOverlay.style.display = 'block';
                });
                closeSideMenuBtn.addEventListener('click', () => {
                    sideMenu.classList.remove('open');
                    sideMenuOverlay.style.display = 'none';
                });
                sideMenuOverlay.addEventListener('click', () => {
                    sideMenu.classList.remove('open');
                    sideMenuOverlay.style.display = 'none';
                });

                const addButtons = [addSphereBtn, addBoxBtn, addCylinderBtn, addHumanBtn];
                addButtons.forEach(button => {
                    // Left-click (desktop) or single tap (mobile)
                    button.addEventListener('click', () => {
                        const objectType = button.dataset.objectType;
                        if (meshes.length >= MAX_OBJECTS) {
                            showMessage(`Unable to add any more objects. Maximum objects allowed is ${MAX_OBJECTS}.`);
                            return;
                        }
                        createObject(objectType, 1);
                        sideMenu.classList.remove('open');
                        sideMenuOverlay.style.display = 'none';
                    });

                    // Right-click (desktop) or long press (mobile) for quantity modal
                    if (isMobile) {
                        let pressTimer;
                        button.addEventListener('touchstart', (event) => {
                            event.stopPropagation(); // Prevent canvas long press
                            pressTimer = setTimeout(() => {
                                currentObjectTypeToAdd = button.dataset.objectType;
                                hideAllMenus();
                                quantityInput.value = 1;
                                quantityModal.style.display = 'flex';
                            }, LONG_PRESS_THRESHOLD);
                        });
                        button.addEventListener('touchend', () => clearTimeout(pressTimer));
                        button.addEventListener('touchmove', () => clearTimeout(pressTimer));
                    } else {
                        button.addEventListener('contextmenu', (event) => {
                            event.preventDefault();
                            currentObjectTypeToAdd = button.dataset.objectType;
                            hideAllMenus();
                            quantityInput.value = 1;
                            quantityModal.style.display = 'flex';
                        });
                    }
                });

                addQuantityBtn.addEventListener('click', () => {
                    console.log("Add Quantity Button clicked.");
                    const quantity = parseInt(quantityInput.value, 10);
                    console.log("Requested quantity:", quantity);
                    console.log("Current object type to add:", currentObjectTypeToAdd);

                    if (isNaN(quantity) || quantity <= 0) {
                        showMessage("Please enter a valid positive number for quantity.");
                        return;
                    }
                    if (meshes.length + quantity > MAX_OBJECTS) {
                        showMessage(`Unable to add any more objects in bulk, try adding them one by one.`);
                        return;
                    }
                    for (let i = 0; i < quantity; i++) {
                        createObject(currentObjectTypeToAdd, 1);
                    }
                    quantityModal.style.display = 'none';
                    sideMenu.classList.remove('open');
                    sideMenuOverlay.style.display = 'none';
                });


                upload3dBtn.addEventListener('click', () => {
                    hideAllMenus();
                    uploadChoiceModal.style.display = 'flex';
                });

                uploadSaveFileBtn.addEventListener('click', () => {
                    fileInput.accept = '.json';
                    fileInput.click();
                    uploadChoiceModal.style.display = 'none';
                });

                import3DModelBtn.addEventListener('click', () => {
                    fileInput.accept = '.gltf, .glb';
                    fileInput.click();
                    uploadChoiceModal.style.display = 'none';
                });

                fileInput.addEventListener('change', handleFileUpload);

                removeItemsButton.addEventListener('click', toggleRemoveMode);

                clearAllObjectsBtn.addEventListener('click', () => {
                    clearAllObjects();
                    contextMenu.style.display = 'none';
                });

                saveAs3DModelBtn.addEventListener('click', () => {
                    saveSceneState();
                    contextMenu.style.display = 'none';
                });

                document.addEventListener('click', (event) => {
                    if (event.target.closest('#contextMenu') === null) {
                        contextMenu.style.display = 'none';
                    }
                });

                document.querySelectorAll('button').forEach(button => {
                    if (button.dataset.tooltip) {
                        button.addEventListener('mouseover', (event) => {
                            showTooltip(button.dataset.tooltip, event.clientX, event.clientY);
                        });
                        button.addEventListener('mouseout', hideTooltip);
                    }
                });

                console.log("Simulator initialized successfully.");

            } catch (error) {
                console.error("Error during initialization:", error);
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const fileName = file.name.toLowerCase();

            if (fileName.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const sceneData = JSON.parse(e.target.result);
                        loadSceneState(sceneData);
                        console.log("Loaded scene state from JSON file.");
                    } catch (error) {
                        console.error("Error parsing JSON file:", error);
                        showMessage("Error loading JSON scene state. Please ensure it's a valid scene state file.");
                    }
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e);
                    showMessage("Error reading file. Please try again.");
                };
                reader.readAsText(file);
            } else if (fileName.endsWith('.gltf') || fileName.endsWith('.glb')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loader = new THREE.GLTFLoader();
                        loader.parse(e.target.result, '', (gltf) => {
                            clearAllObjects();
                            const model = gltf.scene;

                            const box = new THREE.Box3().setFromObject(model);
                            const size = box.getSize(new THREE.Vector3());
                            const center = box.getCenter(new THREE.Vector3());

                            const maxDim = Math.max(size.x, size.y, size.z);
                            const scale = 5 / maxDim;
                            model.scale.set(scale, scale, scale);

                            box.setFromObject(model);
                            center.copy(box.getCenter(new THREE.Vector3()));

                            model.position.y -= center.y - (box.min.y - model.position.y);
                            model.position.x -= center.x;
                            model.position.z -= center.z;

                            model.position.y += 5 + Math.random() * 5;

                            model.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    if (!(child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial)) {
                                        child.material = new THREE.MeshLambertMaterial({ color: child.material.color || 0xcccccc });
                                    }
                                }
                            });

                            model.userData = { name: 'Custom 3D Model' };

                            const modelPhysicsShape = createPhysicsShapeFromMesh(model);
                            if (modelPhysicsShape) {
                                const modelPhysicsBody = new CANNON.Body({ mass: 1, shape: modelPhysicsShape });
                                modelPhysicsBody.position.copy(model.position);
                                world.addBody(modelPhysicsBody);
                                bodies.push(modelPhysicsBody);
                                meshes.push(model);
                                scene.add(model);
                                console.log("Loaded 3D model from GLTF/GLB file.");
                            } else {
                                console.warn("Could not create a physics body for the loaded 3D model.");
                                scene.add(model);
                                meshes.push(model);
                                showMessage("Loaded 3D model, but could not create a precise physics body for it. It might not interact correctly with physics.");
                            }

                        }, undefined, (error) => {
                            console.error("Error loading GLTF/GLB model:", error);
                            showMessage("Error loading 3D model. Please ensure it's a valid GLTF/GLB file.");
                        });
                    } catch (error) {
                        console.error("Error parsing GLTF/GLB file:", error);
                        showMessage("Error loading 3D model. Please ensure it's a valid GLTF/GLB file.");
                    }
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e);
                    showMessage("Error reading file. Please try again.");
                };
                reader.readAsArrayBuffer(file);
            } else {
                showMessage("Unsupported file type. Please upload a .json, .gltf, or .glb file.");
            }
            event.target.value = '';
        }

        function createPhysicsShapeFromMesh(mesh) {
            const box = new THREE.Box3().setFromObject(mesh);
            const size = box.getSize(new THREE.Vector3());
            const halfExtents = new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2);
            return new CANNON.Box(halfExtents);
        }

        function createObject(type, count) {
            console.log(`Attempting to create ${count} object(s) of type: ${type}`);
            for (let i = 0; i < count; i++) {
                let geometry, material, mesh, body;
                const mass = 1;
                const color = new THREE.Color(Math.random() * 0xffffff);
                const initialY = 5 + Math.random() * 5;
                const initialX = (Math.random() - 0.5) * 10;
                const initialZ = (Math.random() - 0.5) * 10;
                let objectName = '';

                switch (type) {
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(1, 32, 32);
                        material = new THREE.MeshLambertMaterial({ color: color });
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        body = new CANNON.Body({ mass: mass, shape: new CANNON.Sphere(1) });
                        objectName = 'Sphere';
                        break;
                    case 'box':
                        geometry = new THREE.BoxGeometry(2, 2, 2);
                        material = new THREE.MeshLambertMaterial({ color: color });
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        body = new CANNON.Body({ mass: mass, shape: new CANNON.Box(new CANNON.Vec3(1, 1, 1)) });
                        objectName = 'Box';
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
                        material = new THREE.MeshLambertMaterial({ color: color });
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        body = new CANNON.Body({ mass: mass, shape: new CANNON.Cylinder(1, 1, 2, 32) });
                        objectName = 'Cylinder';
                        break;
                    case 'human':
                        const humanGroup = new THREE.Group();
                        const bodyHeight = 2.5;
                        const bodyRadius = 0.5;
                        const headRadius = 0.7;

                        const bodyGeometry = new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyHeight, 16);
                        const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                        const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                        bodyMesh.position.y = bodyHeight / 2;
                        bodyMesh.castShadow = true;
                        bodyMesh.receiveShadow = true;
                        humanGroup.add(bodyMesh);

                        const headGeometry = new THREE.SphereGeometry(headRadius, 16, 16);
                        const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFA07A });
                        const headMesh = new THREE.Mesh(headGeometry, headMaterial);
                        headMesh.position.y = bodyHeight + headRadius;
                        headMesh.castShadow = true;
                        headMesh.receiveShadow = true;
                        humanGroup.add(headMesh);

                        mesh = humanGroup;
                        const humanBox = new THREE.Box3().setFromObject(humanGroup);
                        const humanSize = humanBox.getSize(new THREE.Vector3());
                        const humanHalfExtents = new CANNON.Vec3(humanSize.x / 2, humanSize.y / 2, humanSize.z / 2);
                        body = new CANNON.Body({ mass: mass, shape: new CANNON.Box(humanHalfExtents) });
                        body.position.y += humanSize.y / 2;
                        objectName = 'Human';
                        break;
                    default:
                        console.error("Unknown object type:", type);
                        return;
                }

                mesh.position.set(initialX, initialY, initialZ);
                body.position.copy(mesh.position);
                mesh.userData = { name: objectName };

                scene.add(mesh);
                world.addBody(body);
                meshes.push(mesh);
                bodies.push(body);
                console.log(`Added a ${objectName}. Total objects: ${meshes.length}`);
            }
        }

        function clearAllObjects() {
            while (meshes.length > 0) {
                const mesh = meshes.pop();
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) {
                    if (Array.isArray(mesh.material)) {
                        mesh.material.forEach(m => m.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
            }
            while (bodies.length > 0) {
                const body = bodies.pop();
                world.removeBody(body);
            }
            highlightedObject = null;
            originalMaterials.clear();
            console.log("All objects cleared.");
        }

        function saveSceneState() {
            const sceneData = [];
            meshes.forEach((mesh, index) => {
                const body = bodies[index];
                if (mesh && body) {
                    let type = 'unknown';
                    if (mesh.geometry) {
                        if (mesh.geometry.type === 'SphereGeometry') type = 'sphere';
                        else if (mesh.geometry.type === 'BoxGeometry') type = 'box';
                        else if (mesh.geometry.type === 'CylinderGeometry') type = 'cylinder';
                    } else if (mesh.isGroup) {
                        type = 'human';
                    }

                    sceneData.push({
                        type: type,
                        position: { x: body.position.x, y: body.position.y, z: body.position.z },
                        quaternion: { x: body.quaternion.x, y: body.quaternion.y, z: body.quaternion.z, w: body.quaternion.w },
                        velocity: { x: body.velocity.x, y: body.velocity.y, z: body.velocity.z },
                        angularVelocity: { x: body.angularVelocity.x, y: body.angularVelocity.y, z: body.angularVelocity.z },
                        color: mesh.material && mesh.material.color ? mesh.material.color.getHex() : null
                    });
                }
            });
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(sceneData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "gravity_sandbox_scene.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            console.log("Scene state saved.");
        }

        function loadSceneState(sceneData) {
            clearAllObjects();
            sceneData.forEach(objData => {
                let geometry, material, mesh, body;
                const mass = 1;
                const color = objData.color ? new THREE.Color(objData.color) : new THREE.Color(Math.random() * 0xffffff);
                let objectName = '';

                switch (objData.type) {
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(1, 32, 32);
                        material = new THREE.MeshLambertMaterial({ color: color });
                        mesh = new THREE.Mesh(geometry, material);
                        body = new CANNON.Body({ mass: mass, shape: new CANNON.Sphere(1) });
                        objectName = 'Sphere';
                        break;
                    case 'box':
                        geometry = new THREE.BoxGeometry(2, 2, 2);
                        material = new THREE.MeshLambertMaterial({ color: color });
                        mesh = new THREE.Mesh(geometry, material);
                        body = new CANNON.Body({ mass: mass, shape: new CANNON.Box(new CANNON.Vec3(1, 1, 1)) });
                        objectName = 'Box';
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
                        material = new THREE.MeshLambertMaterial({ color: color });
                        mesh = new THREE.Mesh(geometry, material);
                        body = new CANNON.Body({ mass: mass, shape: new CANNON.Cylinder(1, 1, 2, 32) });
                        objectName = 'Cylinder';
                        break;
                    case 'human':
                        const humanGroup = new THREE.Group();
                        const bodyHeight = 2.5;
                        const bodyRadius = 0.5;
                        const headRadius = 0.7;

                        const bodyGeometry = new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyHeight, 16);
                        const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                        const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                        bodyMesh.position.y = bodyHeight / 2;
                        humanGroup.add(bodyMesh);

                        const headGeometry = new THREE.SphereGeometry(headRadius, 16, 16);
                        const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFA07A });
                        const headMesh = new THREE.Mesh(headGeometry, headMaterial);
                        headMesh.position.y = bodyHeight + headRadius;
                        humanGroup.add(headMesh);
                        mesh = humanGroup;

                        const humanBox = new THREE.Box3().setFromObject(humanGroup);
                        const humanSize = humanBox.getSize(new THREE.Vector3());
                        const humanHalfExtents = new CANNON.Vec3(humanSize.x / 2, humanSize.y / 2, humanSize.z / 2);
                        body = new CANNON.Body({ mass: mass, shape: new CANNON.Box(humanHalfExtents) });
                        body.position.y += humanSize.y / 2;
                        objectName = 'Human';
                        break;
                    default:
                        console.warn("Skipping unknown object type during load:", objData.type);
                        return;
                }

                mesh.castShadow = true;
                mesh.receiveShadow = true;

                body.position.set(objData.position.x, objData.position.y, objData.position.z);
                body.quaternion.set(objData.quaternion.x, objData.quaternion.y, objData.quaternion.z, objData.quaternion.w);
                body.velocity.set(objData.velocity.x, objData.velocity.y, objData.velocity.z);
                body.angularVelocity.set(objData.angularVelocity.x, objData.angularVelocity.y, objData.angularVelocity.z);
                mesh.userData = { name: objectName };

                scene.add(mesh);
                world.addBody(body);
                meshes.push(mesh);
                bodies.push(body);
            });
            console.log("Scene state loaded successfully.");
        }

        function updateCameraPosition() {
            camera.position.x = cameraTarget.x + cameraDistance * Math.sin(phi) * Math.cos(theta);
            camera.position.y = cameraTarget.y + cameraDistance * Math.cos(phi);
            camera.position.z = cameraTarget.z + cameraDistance * Math.sin(phi) * Math.sin(theta);
            camera.lookAt(cameraTarget);
        }

        // --- Mouse Event Handlers (Desktop) ---
        function onMouseDown(event) {
            if (event.button === 0) {
                isDragging = true;
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            }
        }

        function onMouseUp(event) {
            if (event.button === 0) {
                isDragging = false;
            }
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;

                theta -= deltaX * 0.005;
                phi -= deltaY * 0.005;

                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                updateCameraPosition();

                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            }

            // Highlighting and tooltip for desktop
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(meshes, true);

            let newHoveredMesh = null;
            if (intersects.length > 0) {
                for (let i = 0; i < intersects.length; i++) {
                    const intersectedMesh = intersects[i].object;
                    let currentMesh = intersectedMesh;
                    while (currentMesh && !meshes.includes(currentMesh)) {
                        currentMesh = currentMesh.parent;
                    }
                    if (currentMesh && meshes.includes(currentMesh)) {
                        newHoveredMesh = currentMesh;
                        break;
                    }
                }
            }

            if (newHoveredMesh !== currentHoveredMesh) {
                if (currentHoveredMesh && !removeModeActive) {
                    const originalMaterial = originalMaterials.get(currentHoveredMesh.uuid);
                    if (originalMaterial) {
                        currentHoveredMesh.material = originalMaterial;
                    }
                }
                clearTimeout(meshHoverTimer);
                hideTooltip();

                currentHoveredMesh = newHoveredMesh;

                if (currentHoveredMesh) {
                    meshHoverTimer = setTimeout(() => {
                        if (currentHoveredMesh && currentHoveredMesh.userData && currentHoveredMesh.userData.name) {
                            showTooltip(currentHoveredMesh.userData.name, event.clientX, event.clientY);
                        }
                    }, 2000);

                    if (removeModeActive) {
                        if (!originalMaterials.has(currentHoveredMesh.uuid)) {
                            originalMaterials.set(currentHoveredMesh.uuid, currentHoveredMesh.material);
                        }
                        currentHoveredMesh.material = highlightMaterial;
                    }
                }
            } else if (currentHoveredMesh && removeModeActive) {
                if (!originalMaterials.has(currentHoveredMesh.uuid)) {
                    originalMaterials.set(currentHoveredMesh.uuid, currentHoveredMesh.material);
                }
                currentHoveredMesh.material = highlightMaterial;
            }

            if (!removeModeActive && highlightedObject) {
                const originalMaterial = originalMaterials.get(highlightedObject.uuid);
                if (originalMaterial) {
                    highlightedObject.material = originalMaterial;
                }
                highlightedObject = null;
                originalMaterials.clear();
            }
            highlightedObject = currentHoveredMesh;
        }


        function onMouseWheel(event) {
            event.preventDefault();
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(5, Math.min(100, cameraDistance));
            updateCameraPosition();
        }

        function onContextMenu(event) {
            event.preventDefault();
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
        }

        // --- Touch Event Handlers (Mobile) ---
        function onTouchStart(event) {
            touchCount = event.touches.length;
            hideTooltip(); // Hide tooltip immediately on touch

            if (touchCount === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                longPressTimer = setTimeout(() => {
                    onContextMenu({ clientX: event.touches[0].clientX, clientY: event.touches[0].clientY, preventDefault: () => {} });
                }, LONG_PRESS_THRESHOLD);
            } else if (touchCount === 2) {
                initialPinchDistance = getPinchDistance(event.touches);
                clearTimeout(longPressTimer); // Cancel long press if two fingers are used
            }
        }

        function onTouchMove(event) {
            clearTimeout(longPressTimer); // Cancel long press if finger moves

            if (event.touches.length === 1 && touchCount === 1) {
                // One-finger drag for camera rotation
                const deltaX = event.touches[0].clientX - touchStartX;
                const deltaY = event.touches[0].clientY - touchStartY;

                theta -= deltaX * 0.005;
                phi -= deltaY * 0.005;

                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                updateCameraPosition();

                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;

                // Update mouse for raycasting for highlighting
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                handleHighlighting();

            } else if (event.touches.length === 2 && touchCount === 2) {
                // Two-finger pinch for zoom
                const currentPinchDistance = getPinchDistance(event.touches);
                const deltaPinch = currentPinchDistance - initialPinchDistance;

                cameraDistance -= deltaPinch * 0.05; // Adjust zoom sensitivity
                cameraDistance = Math.max(5, Math.min(100, cameraDistance));
                updateCameraPosition();

                initialPinchDistance = currentPinchDistance;
            }
        }

        function onTouchEnd(event) {
            clearTimeout(longPressTimer);
            const canvas = document.getElementById('physicsCanvas');

            // If it was a single tap and not a drag, consider it a click for removal mode
            if (event.changedTouches.length === 1 && touchCount === 1) {
                const touch = event.changedTouches[0];
                const deltaX = Math.abs(touch.clientX - touchStartX);
                const deltaY = Math.abs(touch.clientY - touchStartY);

                // Define a small threshold for a "tap" vs. a "drag"
                const tapThreshold = 10;

                if (deltaX < tapThreshold && deltaY < tapThreshold) {
                    // This was a tap
                    // Simulate a click event for onClickCanvas
                    const simulatedClickEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0, // Left mouse button equivalent
                        preventDefault: () => {}
                    };
                    onClickCanvas(simulatedClickEvent);
                }
            }
            touchCount = 0; // Reset touch count
            // Ensure highlight is removed if not in remove mode
            if (!removeModeActive && highlightedObject) {
                const originalMaterial = originalMaterials.get(highlightedObject.uuid);
                if (originalMaterial) {
                    highlightedObject.material = originalMaterial;
                }
                highlightedObject = null;
                originalMaterials.clear();
            }
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleHighlighting() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(meshes, true);

            let newHoveredMesh = null;
            if (intersects.length > 0) {
                for (let i = 0; i < intersects.length; i++) {
                    const intersectedMesh = intersects[i].object;
                    let currentMesh = intersectedMesh;
                    while (currentMesh && !meshes.includes(currentMesh)) {
                        currentMesh = currentMesh.parent;
                    }
                    if (currentMesh && meshes.includes(currentMesh)) {
                        newHoveredMesh = currentMesh;
                        break;
                    }
                }
            }

            if (newHoveredMesh !== currentHoveredMesh) {
                if (currentHoveredMesh && !removeModeActive) {
                    const originalMaterial = originalMaterials.get(currentHoveredMesh.uuid);
                    if (originalMaterial) {
                        currentHoveredMesh.material = originalMaterial;
                    }
                }
                clearTimeout(meshHoverTimer);
                hideTooltip();

                currentHoveredMesh = newHoveredMesh;

                if (currentHoveredMesh) {
                    meshHoverTimer = setTimeout(() => {
                        if (currentHoveredMesh && currentHoveredMesh.userData && currentHoveredMesh.userData.name) {
                            // Use the last known touch/mouse coordinates for tooltip position
                            const x = isMobile ? touchStartX : mouse.x * window.innerWidth / 2 + window.innerWidth / 2;
                            const y = isMobile ? touchStartY : -mouse.y * window.innerHeight / 2 + window.innerHeight / 2;
                            showTooltip(currentHoveredMesh.userData.name, x, y);
                        }
                    }, 2000);

                    if (removeModeActive) {
                        if (!originalMaterials.has(currentHoveredMesh.uuid)) {
                            originalMaterials.set(currentHoveredMesh.uuid, currentHoveredMesh.material);
                        }
                        currentHoveredMesh.material = highlightMaterial;
                    }
                }
            } else if (currentHoveredMesh && removeModeActive) {
                if (!originalMaterials.has(currentHoveredMesh.uuid)) {
                    originalMaterials.set(currentHoveredMesh.uuid, currentHoveredMesh.material);
                }
                currentHoveredMesh.material = highlightMaterial;
            }
            highlightedObject = currentHoveredMesh;
        }

        function onClickCanvas(event) {
            if (removeModeActive) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(meshes, true);

                if (intersects.length > 0) {
                    let objectToRemove = null;
                    for (let i = 0; i < intersects.length; i++) {
                        const intersectedMesh = intersects[i].object;
                        let currentMesh = intersectedMesh;
                        while (currentMesh && !meshes.includes(currentMesh)) {
                            currentMesh = currentMesh.parent;
                        }
                        if (currentMesh && meshes.includes(currentMesh)) {
                            objectToRemove = currentMesh;
                            break;
                        }
                    }

                    if (objectToRemove) {
                        const index = meshes.indexOf(objectToRemove);
                        if (index !== -1) {
                            scene.remove(meshes[index]);
                            world.removeBody(bodies[index]);
                            meshes.splice(index, 1);
                            bodies.splice(index, 1);
                            if (objectToRemove === highlightedObject) {
                                highlightedObject = null;
                            }
                            originalMaterials.delete(objectToRemove.uuid);
                            console.log("Object removed.");
                        }
                    }
                }
            }
        }

        function toggleRemoveMode() {
            removeModeActive = !removeModeActive;
            removeItemsButton.classList.toggle('active', removeModeActive);
            if (!removeModeActive && highlightedObject) {
                const originalMaterial = originalMaterials.get(highlightedObject.uuid);
                if (originalMaterial) {
                    highlightedObject.material = originalMaterial;
                }
                highlightedObject = null;
                originalMaterials.clear();
            }
            if (!removeModeActive) {
                clearTimeout(meshHoverTimer);
                hideTooltip();
                currentHoveredMesh = null;
            }
            console.log("Remove mode active:", removeModeActive);
        }

        function hideAllMenus() {
            controlsModal.style.display = 'none';
            geminiModal.style.display = 'none';
            uploadChoiceModal.style.display = 'none';
            sideMenu.classList.remove('open');
            sideMenuOverlay.style.display = 'none';
            contextMenu.style.display = 'none';
            quantityModal.style.display = 'none';
            hideTooltip();
            showMessage('', 0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            world.step(1 / 60);

            for (let i = 0; i < meshes.length; i++) {
                meshes[i].position.copy(bodies[i].position);
                meshes[i].quaternion.copy(bodies[i].quaternion);
            }

            renderer.render(scene, camera);
        }

        function showTooltip(text, clientX, clientY) {
            clearTimeout(tooltipTimeout);
            customTooltip.textContent = text;

            customTooltip.classList.add('show');
            const tooltipRect = customTooltip.getBoundingClientRect();
            customTooltip.classList.remove('show');

            const padding = 10;

            let finalX = clientX + padding;
            let finalY = clientY + padding;

            if (finalX + tooltipRect.width > window.innerWidth) {
                finalX = clientX - tooltipRect.width - padding;
                if (finalX < 0) {
                    finalX = 0;
                }
            }

            if (finalY + tooltipRect.height > window.innerHeight) {
                finalY = clientY - tooltipRect.height - padding;
                if (finalY < 0) {
                    finalY = 0;
                }
            }

            customTooltip.style.left = `${finalX}px`;
            customTooltip.style.top = `${finalY}px`;
            customTooltip.classList.add('show');
        }

        function hideTooltip() {
            clearTimeout(tooltipTimeout);
            customTooltip.classList.remove('show');
        }

        function showMessage(message, duration = 3000) {
            clearTimeout(messageBoxTimeout);
            messageBox.textContent = message;
            messageBox.classList.add('show');
            if (duration > 0) {
                messageBoxTimeout = setTimeout(() => {
                    messageBox.classList.remove('show');
                }, duration);
            }
        }

        window.onload = function () {
            init();
            animate();
        }
    </script>
</body>
</html>